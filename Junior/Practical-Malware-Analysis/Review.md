# Malware Analysis2023 

*by ErwinZhou*

![image-20231226233442370](img/image-20231226233442370.png)

## 一.概述

<img src="img/image-20231226233551926.png" alt="image-20231226233551926" style="zoom: 50%;" />



![image-20231229001833614](img/image-20231229001833614.png)

1. **分析目标（主要）**

<img src="img/image-20231226233635253.png" alt="image-20231226233635253" style="zoom: 67%;" />

2. 思政：**西北工业大学（TAO美国特定入侵行动办公室）**，CIA网络攻击，武汉地震检测中心（美国情报机构）

<img src="img/image-20231226233817797.png" alt="image-20231226233817797" style="zoom:50%;" />

ABCD

<img src="img/image-20231226233943136.png" alt="image-20231226233943136" style="zoom: 50%;" />

![image-20231229001854257](img/image-20231229001854257.png)

**实际上机器学习加快了计算机病毒进化的过程。**

<img src="img/image-20231226234224733.png" alt="image-20231226234224733" style="zoom:50%;" />

**==分析目标==**

* 究竟发生了什么

* 确保定位所有的受感染主机和文件

* **解剖所有可疑的文件（对可疑程序进程深入分析，确定该程序是否有恶意行为）——事件响应的关键步骤**

  * 如何工作的

  * 如何识别他

  * 如何防御或者消除它

    <img src="img/image-20231226234856720.png" alt="image-20231226234856720" style="zoom:50%;" />



* **找到病毒签名来检测**

  * 基于主机的签名

  * 基于网络的签名

    <img src="img/image-20231226235045124.png" alt="image-20231226235045124" style="zoom:67%;" />

* 使用机器学习建立探测模型

* 如何去衡量并且稳定住病毒造成的损失（衡量并消除恶意代码对系统造成的破坏）

![image-20231226234332251](img/image-20231226234332251.png)

3. Yara：**Identify and Classify即识别并分类**。

   保留问题？

<img src="img/image-20231226235222991.png" alt="image-20231226235222991" style="zoom:50%;" />

4. **动静态分析的概念：**

   ![image-20231229001934326](img/image-20231229001934326.png)

* **静态分析：**不运行文件的前提下检查恶意文件。VirusTotal，strings，**反汇编器(disassembler)**像是IDA Pro。

* **动态分析：**运行恶意代码并观察其效果。虚拟机并使用快照。

  RegShot，Process Monitor, Process Hacker, CaptureBAT
  
  RAM分析：
  
  ![image-20231229002147448](img/image-20231229002147448.png)
  
  *Volatility*是一个内存取证框架。主要用于事件响应和恶意软件分析。使用此工具,你可以从正在运行的进程,网络套接字,网络连接,DLL和注册表蜂巢提取信息。

5. **病毒的类型：**

   ![image-20231229002329917](img/image-20231229002329917.png)

   * **Backdoor：**后门。允许攻击者能够控制系统。
   * ![image-20240107150249671](img/image-20240107150249671.png)
   * ![image-20240107150342956](img/image-20240107150342956.png)

![image-20240107150536362](img/image-20240107150536362.png)

Worms or viruses：

![image-20240107150602631](img/image-20240107150602631.png)

![image-20240107152322889](img/image-20240107152322889.png)

![image-20240107152712655](img/image-20240107152712655.png)

![image-20240107152757918](img/image-20240107152757918.png)

* **Botnet：**所有受感染主机都会接收来自一个C&C服务器的指示。

   * **Downloader：**下载器。恶意代码的存在仅是为了下载其他的恶意代码。会在攻击者首次获得权限时候运行。

   <img src="img/image-20231227001757997.png" alt="image-20231227001757997" style="zoom: 67%;" />

   * **Information-stealing malware**

* **Launcher：stealth隐藏**
   * **Rootkit**

   <img src="img/image-20231229002519785.png" alt="image-20231229002519785" style="zoom:67%;" />

   * **Scareware**

     <img src="img/image-20231229002906314.png" alt="image-20231229002906314" style="zoom:67%;" />

   * **Spam-sending malware**

   * **Worms or viruses：**

   * **Ransomware：勒索病毒。**

   <img src="img/image-20231227185806668.png" alt="image-20231227185806668" style="zoom:67%;" />

   **总结：**

   <img src="img/image-20231229002958074.png" alt="image-20231229002958074" style="zoom:67%;" />

   按照攻击对象进行划分：

   * **Mass malware：**

   * **Targeted malware（APT）：更难以被检测到。Stuxnet。**

     <img src="img/image-20231229003402877.png" alt="image-20231229003402877" style="zoom:50%;" />

     <img src="img/image-20231229003446129.png" alt="image-20231229003446129" style="zoom:67%;" />

   

6. **基本方法：**

* 基本分析：

  * 静态：VirusTotal和strings。
  * 动态：简单但是需要安全的测试环境。并不是对所有恶意代码都有效。

  <img src="img/image-20231227001417276.png" alt="image-20231227001417276" style="zoom:67%;" />

  

* 进阶分析：

  * **静态：使用反汇编器的逆向工程。**复杂，需要对汇编代码、组织和操作系统相关概念足够熟悉。
  * **动态：需要通过调试器运行程序。**Debugger。检查运行恶意代码可执行程序的某个中间状态。

  <img src="img/image-20231227001435774.png" alt="image-20231227001435774" style="zoom:67%;" />

<img src="img/image-20231226235259190.png" alt="image-20231226235259190" style="zoom:67%;" />

**ABCD**

<img src="img/image-20231227001128790.png" alt="image-20231227001128790" style="zoom:67%;" />



7. **其他：**

   * 不要陷入细节
   * 尝试多种工具
   * “猫鼠”游戏

   <img src="img/image-20231229003535587.png" alt="image-20231229003535587" style="zoom:67%;" />

   ![image-20231229003618230](img/image-20231229003618230.png)



## 二.基本静态分析技术

基本静态分析工具及其功能

1. 概述：reverse engineering, **not run**。**逆向分析一个二进制可执行文件的代码或者框架去理解它的行为功能。**

2. **基本静态分析：不进行反汇编；**是动态分析和高级分析的provide good pointers
    可以从二进制代码里面找到**没有被加密的信息**，例如URLs、要感染的文件名、要修改的注册表键值、调用的Windows API函数名等等。涉及到的技术有：
* Antivirus scanning
* Hashes
* A file's strings, funtions, headers
  <img src="img/image-20231229105223649.png" alt="image-20231229105223649" style="zoom:67%;" />

  <img src="img/image-20231229105353519.png" alt="image-20231229105353519" style="zoom:50%;" />

3. **Antivirus sacnning：**卡巴斯基、诺顿、Mcafee、Trend等。

   * **基本分类：**

     * 已知病毒：病毒签名、启发式算法
     * 未知病毒：Obfuscation混淆
       Polymorphic（多态）: syntax obfuscation 语法混淆
       Metamorphic（变形）: semantic obfuscation 语义混淆
     * ![image-20240107153331573](img/image-20240107153331573.png)

     ![image-20231229105901453](img/image-20231229105901453.png)

   * (Collection of Antivirus Toools)集大成者VirusTotal

4. **Hashes：Method to uniquely identify malware**

   eg.**HashCalc**

   * **优缺点**

   ![image-20231229110143354](img/image-20231229110143354.png)

   * 基本技术：
   
     * MD5：Message-Digest Algorithm
       （128-bit hash）
     * SHA1：Secure Hash Algorithm
       （160-bit hash）

   * arbitary：任意的；MD5会发生碰撞不会不经常发生（碰撞即有相同的Hash值）
   
     <img src="img/image-20231229110643146.png" alt="image-20231229110643146" style="zoom: 67%;" />
     
   * 用途：**标签；共享；前人之鉴**
   
     ![image-20231229110936128](img/image-20231229110936128.png)
   
5. Strings：a sequence of printable characters.

   * Use 0 and 1 to represent characters

     **![image-20231229111357820](img/image-20231229111357820.png)**

     **ASCII：8 bit。**
     **UNICODE：16 bit。**135 modern or historic scripts

     ![image-20240102144605808](img/image-20240102144605808.png)

   * Search binary executable for **ASCII and Unicode** strings 
     **Three or greater** sequence of characters
     Followed by a **terminator**

   * **隐藏字符串：==加密，加壳，压缩，混淆。==**

   * ![image-20240107161743095](img/image-20240107161743095.png)

     ![image-20231229111443426](img/image-20231229111443426.png)

   * Packed and Obfuscated Malware：**==加壳是混淆的子集！==**

     **共同目标：压缩体积，隐藏重要信息。使病毒更难以被逆向或者探测**

     * **混淆：隐藏可执行信息**

     * 加壳：压缩二进制文件大小。令strings和指令都无法被阅读。**只能看到wrapper，unpack运行时。**

       eg.UPX---->PEiD

       ![image-20231229113831085](img/image-20231229113831085.png)

     * 合法的程序很多strings，加壳或者混淆后一般来说会很少。不过也不一定。**==不一定减少字符串的数量，因为会出现很多垃圾字符串==**

       ![image-20231229114347970](img/image-20231229114347970.png)

6. **==可执行文件格式：==**

   Windows中的exe和DLLs。（**几乎**所有在Windows上执行的文件都是PE格式）Contains the information necessary for **Windows to load the binary executable**

   ![image-20231229114421422](img/image-20231229114421422.png)

   * **==PE文件头：==**

     ![image-20231229132510875](img/image-20231229132510875.png)

     * Information about the code
     * Type of application
     * Required library functions
     * Space requirements
     * Code Entry point

   * 工具：LordPE

7. Linked Libraries and Functions连接库函数

   * 导入：Connected to the main EXE by **Linking。即从另一个程序如库中导入函数。**

   * **三种链接方式：Statically, At Runtime, Dynamically**

     ![image-20231229133707206](img/image-20231229133707206.png)

     * **Static Linking**：Windows的exe很少使用，Unix and Linux常用。库中代码直接复制过来，更多内存空间，文件大小更大。

     * **Dynamical Linking：**最常见的方式。**load加载程序时候搜索！**

       ![image-20231229133201029](img/image-20231229133201029.png)

     * **==Runtime Linking：在合法的程序中不常用，但是在malware中，尤其是加壳和混淆过的很常见。==**

       * Connect to libraries **only when needed**, not when the program starts
       * **LoadLibrary, GetProcAddress**

     * **PE文件头**包含了线索

       ![image-20231229133652780](img/image-20231229133652780.png)

8. **Dependency Walker：Shows ==Dynamically（普通程序多，病毒少）== Linked Functions。**

   * **<font size=5, color="red">常见DLLs</font>**

     **Advapi32.dll：服务Manager和注册表**

     User32：用户接口组件，按钮。包括回复用户响应窗口等。

     Gdi32：画图

     **Ntdll：Windows内核的接口。**通过Kernel间接导入。**想要使用一些一般的Windows程序不允许使用的。隐藏功能与操作进程用到。**

     <img src="img/image-20231229134102827.png" alt="image-20231229134102827" style="zoom:67%;" />

     ![image-20231229134226717](img/image-20231229134226717.png)

   * **DLL导出函数，EXE导入函数。**

     Both exports and imports are listed in the **PE header**

9. **PE文件头和节：**

   ![image-20231229134615446](img/image-20231229134615446.png)

   * Time Data Stamp：**编译**的时间。老的病毒更出名。有时候会错，可以造假。
	  <img src="img/image-20231229134840499.png" alt="image-20231229134840499" style="zoom:67%;" />
	
	* **IMAGE_SECTION_HEADER**
	
	  RAM虚拟，Size of Raw Data。一般对于.text节二者近乎相等。**但加壳的文件前者大很多。**
	
	  ​	<img src="img/image-20231229134949319.png" alt="image-20231229134949319" style="zoom:67%;" />
	
	* **Resource Hacker：浏览.rsrc节。**Strings, icons, and menus

## 三.Yara检测引擎

![image-20231229135447962](img/image-20231229135447962.png)

![image-20231229135455843](img/image-20231229135455843.png)

Yara就是把静态分析的结果等转换为杀毒软件

* **VirusTotal开发，开源查杀恶意代码。识别与分类。引擎跨平台。**

* 本身不提供杀毒功能。没有特征库，需要编写Yara规则，以此来识别和分类恶意软件或者程序。

  <img src="img/image-20231229135739720.png" alt="image-20231229135739720" style="zoom: 67%;" />

* 直接编写python程序来调用Yara引擎。

1. 正则表达式

2. **Yara规则（重点）**正则与条件表达式。

   ![image-20231229135913851](img/image-20231229135913851.png)

   * **Yara规则：==一系列字符串和一个布尔型表达式==。支持与或非等多种条件。**

     * **规则标识符Identifier，==第一个字符不能是数字，长度不超过128字符，区分大小写。==**

       ![image-20231229140005776](img/image-20231229140005776.png)

       <img src="img/image-20231229140031911.png" alt="image-20231229140031911" style="zoom:67%;" />
       
       注释和C一样
     
   * **Yara字符串：**三种。十六进制（字节！）、文本、**正则表达式。**

       ![image-20231230160730247](img/image-20231230160730247.png)

      * **通配符：?（单位是十六进制数字）**
      ![image-20231230161043188](img/image-20231230161043188.png)

      * **跳转：‘[]’**。**与任何长度为0-2字节的内容匹配。单位是Byte。**
      
        ![image-20231230161547767](img/image-20231230161547767.png)
      
      * **<font size=5, color="red">正则表达式——描述strings的，和后面的条件表达式无关：</font>**
      
        ![image-20231230161639661](img/image-20231230161639661.png)
      
        ![image-20231230161708302](img/image-20231230161708302.png)
      
        * **==元字符==：**
      
          ![image-20231230162310702](img/image-20231230162310702.png)
      
        * **==数量匹配==：**
      
          ![image-20231230162349898](img/image-20231230162349898.png)
      
        * 字符类型定义：
      
          <img src="img/image-20231230162447074.png" alt="image-20231230162447074" style="zoom:67%;" />
      
      * 文本字符串匹配：
      
        ![image-20231230161717117](img/image-20231230161717117.png)
      
        * **修饰符：**
      
          <img src="img/image-20231230161834427.png" alt="image-20231230161834427" style="zoom:67%;" />
      
          <img src="img/image-20231230161853590.png" alt="image-20231230161853590" style="zoom:67%;" />
      
          ![image-20231230161911399](img/image-20231230161911399.png)
      
          **异或修饰符xor——所有可能的异或后字符串**
      
          ![image-20231230162001943](img/image-20231230162001943.png)
      
          **base64编码**
      
          ![image-20231230162034583](img/image-20231230162034583.png)
      
          **全词匹配——即domain前后一定得有别的符号隔开其他单词**
      
          ![image-20231230162209816](img/image-20231230162209816.png)
      
          ![image-20231230162227848](img/image-20231230162227848.png)
   
3. **==Yara条件表达式：==**

   ![image-20231230162529811](img/image-20231230162529811.png)

   ![image-20231230162620155](img/image-20231230162620155.png)

   ![image-20231230162652683](img/image-20231230162652683.png)

   * **==在文件或者内存中==出现次数控制：#**

     ![image-20231230162746622](img/image-20231230162746622.png)
     
   * **==获取字符串出现位置：@。@a[i]。索引从1开始，大于次数NaN。==**

     ![image-20231231105753153](img/image-20231231105753153.png)

   * **==获取字符串长度：！==。!a是!a[1]的缩写。**

     ![image-20231231105916312](img/image-20231231105916312.png)

   * **==指定字符串匹配的位置：at（偏移或者虚拟地址，不是物理！！！！！！）==**

     **<font size=4, color="red">非常关键，可以减少整个文件的search。</font>**

     <img src="img/image-20231231110039481.png" alt="image-20231231110039481" style="zoom:67%;" />

   * **==指定字符串匹配的范围：in==**

     **==filesize表示文件的结尾！！！==**

     <img src="img/image-20231231110131316.png" alt="image-20231231110131316" style="zoom:67%;" />

   * **==文件大小匹配：filesize==** 

     * filesize只在文件时才有用，对进程无效

     * **KB MB后缀只能与十进制大小**一起使用

       <img src="img/image-20231231110303129.png" alt="image-20231231110303129" style="zoom:67%;" />

   * **（PE或ELF文件）入口点匹配：entrypoint**

     **<font size=4, color="red">E8——call 指令。</font>**

     **entrypoint——本身就是程序入口点的==RVA。==**

     **基地址(ImageBase)不是程序的入口点。**

     

     ![image-20231231114024567](img/image-20231231114024567.png)

     不直接感染entrypoint,而是在它的附近。

     <img src="img/image-20231231110427680.png" alt="image-20231231110427680" style="zoom:67%;" />

     

   * ==**读文件或内存数据**==

     * **大端小端序：**

       **Windows小端**

       ![img](img/v2-233887068992518bb4eec56de043d1b2_720w.webp)

     * **intxxx读取==小端有符号==整数**

       ![image-20231231110739099](img/image-20231231110739099.png)

     * **uintxxx读取==小端无符号==整数**

       ![image-20231231110802446](img/image-20231231110802446.png)

     * **intxxxbe读取==大端有符号==整数**

     ![image-20231231110901202](img/image-20231231110901202.png)

     * **uintxxxbe读取==大端无符号==整数**

       ![image-20231231110921874](img/image-20231231110921874.png)

   * **==匹配部分字符串：of。2 of(blablabla)==**

     <img src="img/image-20231231111153534.png" alt="image-20231231111153534" style="zoom:67%;" />

   * **==多字符串匹配：for——“至少”==**

     ![image-20231231114533447](img/image-20231231114533447.png)

   * **==多字符串匹配：any、all、them==**

     在条件表达式中，可以使用**$依次代替字符串集合中的每一个字符串**，#表示字符串的出现次数

     **for 1 = for any**

     **all同时，字符串太多用them**

     ![image-20231231115451667](img/image-20231231115451667.png)

   * **==多字符串匹配：for-in==**

     作用与for of类似，增加了下标变量与下标范围

     ![image-20231231115757654](img/image-20231231115757654.png)

   * **==题目：==**

     ==***在条件表达式中含义是以这个字符串开头**==

     ![image-20231231115839691](img/image-20231231115839691.png)

     ![image-20231231120028354](img/image-20231231120028354.png)

   * **<font size=4, color="red">判断文件是否是PE文件</font>**

     常量（如 `IMAGE_DOS_SIGNATURE` 和 `IMAGE_NT_SIGNATURE`）和偏移地址（`e_lfanew` 的偏移地址是 0x3C）密切相关。

     <img src="img/image-20231231113103577.png" alt="image-20231231113103577" style="zoom:67%;" />

     **![image-20231231113812971](img/image-20231231113812971.png)**

     1. **uint16(0) == 0x5A4D**: 这个条件检查文件的开头两个字节是否为 `0x5A4D`，这对应于 `IMAGE_DOS_SIGNATURE`，即**标准 PE 文件的 MS-DOS 头部标识。**

     2. **uint32(uint32(0x3C)) == 0x00004550**: 这个条件首先在偏移地址 `0x3C` 处读取一个 32 位的值（`e_lfanew`），这个值指向PE头部的开始。接着，**它检查这个位置的值是否为 `0x00004550`，这对应于 `IMAGE_NT_SIGNATURE`，即 PE 头部的标识。**

     ### PE 文件的常量和偏移地址

     在 PE 文件格式中，`IMAGE_DOS_SIGNATURE`（`0x5A4D`）和 `IMAGE_NT_SIGNATURE`（`0x00004550`）是两个关键的常量，分别用于**==标识 MS-DOS 头部和 PE 头部。==**

     1. **MS-DOS 头部**:
        - PE 文件以一个 MS-DOS 兼容头部开始，这个头部被称为 MS-DOS 存根（stub）。这个部分的目的是保持向后兼容性。
        - **在这个头部的偏移 `0x3C` 处，有一个==32 位（4 字节）的字段，这就是 e_lfanew。==**
     2. **e_lfanew 字段的功能**:
        - **`e_lfanew` ==字段存储了一个指向 PE 头部开始位置的偏移值。这个值是从文件的开头计算的。==**
        - **==通过这个偏移值，程序和操作系统可以直接跳到 PE 头部==**，开始解析文件的主要部分。

   * 其他：

     * $a and **IsPE**

     * **==全局规则：比如先筛选文件大小和PE文件格式等。==**

       ![image-20231231120135734](img/image-20231231120135734.png)

     * 私有规则：**不会输出任何匹配到**的私有规则信息。

       ![image-20231231120228095](img/image-20231231120228095.png)

     * **导入模块：==import+“ ”==**

       ![image-20231231120338651](img/image-20231231120338651.png)

     * **外部变量允许使用==YARA -d命令时指定一个自定义数据==。**该数据可以是整数、字符串、布尔变量。

     * **文件包含：**

       ![image-20231231120440702](img/image-20231231120440702.png)

4. **==如何把分析结果->杀毒软件：==**
   回答：利用高效的Yara规则对静态以及动态分析结果的特征进行利用，对病毒进行检测和分类，以及查杀。

5. **==快速过滤，如何更加高效。==**

   回答：

   * 提高效率。先识别PE文件格式或者文件大小。global指令。
   * at和in指令减少搜索范围。

## 四.虚拟机技术

结构和安装不考

![image-20231231120635702](img/image-20231231120635702.png)

1. Fresh malware can be full of surprises：伪装；恶意软件载荷；技术进化；社会工程学
2. 动态分析需要主动地运行恶意代码，监控并分析恶意代码的运行结果。==**因此需要安全、可控的运行环境。**==
   * **<font size=4, color="red">隔离：</font>**阻止动态分析计算机与互联网和其他计算机的网络连接
   * **<font size=4, color="red">清理：</font>**分析结束后，要清除计算机中的病毒

**物理机**

<img src="img/image-20231231120806919.png" alt="image-20231231120806919" style="zoom:67%;" />

![image-20240101154224530](img/image-20240101154224530.png)

**虚拟机**

![image-20240101154525092](img/image-20240101154525092.png)

<img src="img/image-20231231120823566.png" alt="image-20231231120823566" style="zoom:67%;" />

XP：（自身）体积小，安装快；兼容性更好（病毒）恶意代码的攻击目标

<img src="img/image-20231230162909517.png" alt="image-20231230162909517" style="zoom:67%;" />

**网络**

在虚拟机中可以连接互联网。但是风险（病毒扩散，DDoS攻击、Spam垃圾邮件）。可以预先分析。

![image-20240101155209614](img/image-20240101155209614.png)

![image-20240101155102739](img/image-20240101155102739.png)

<img src="img/image-20231231121119359.png" alt="image-20231231121119359" style="zoom: 67%;" />

文件传输：drag-and-drop以及Shared folder。

![image-20240101155330041](img/image-20240101155330041.png)

**==虚拟机也有安全风险==**

1. 计算机病毒会检测到自己运行在一个虚拟机中，改变其动态行为；

2. VMware（虚拟机软件）的安全漏洞：计算机病毒会利用VMware的漏洞（drag-and-drop漏洞）进行攻击。

   **解决措施：需要及时打补丁，防止入侵！**

3. **虚拟机逃逸：**计算机病毒有可能感染和破坏主机。不要使用存储重要数据的计算机进行病毒分析。

<img src="img/image-20231231121133090.png" alt="image-20231231121133090" style="zoom:67%;" />

![image-20231231121153395](img/image-20231231121153395.png)



1. 优点：隔离，防攻击和勒索
2. 缺点：不100%安全（有风险）
3. 打补丁，防止入侵
4. 虚拟机中执行的结果可能不同

![image-20240101155523514](img/image-20240101155523514.png)

## 五.基本动态分析

**Malware的开机自启动——修改注册表。**

![image-20240101160141821](img/image-20240101160141821.png)

**为什么要进行动态分析？**

![image-20240101160159686](img/image-20240101160159686.png)

可执行文件压缩工具——UPX

<img src="img/image-20240101160033215.png" alt="image-20240101160033215" style="zoom: 80%;" />

1. **基本动态分析工具及其功能**
   
   ![image-20240101161733381](img/image-20240101161733381.png)
   
   * **Procmon：**Monitors **==registry, file system, network, process, and thread activity==**
   
     ![image-20240101162056949](img/image-20240101162056949.png)
   
     **可以过滤**
   
     ![image-20240101161754625](img/image-20240101161754625.png)
   
     **不要运行太久——不然会耗尽内存。**
   
     ![image-20240101161911523](img/image-20240101161911523.png)
   
     Exclude与Include
   
     ![image-20240101164631758](img/image-20240101164631758.png)
   
     ![image-20240101164642034](img/image-20240101164642034.png)
   
     ![image-20240101162030785](img/image-20240101162030785.png)
   
   * **Process Explorer：和Procmon的区别？**
   
     list active processes **in a tree structure that displays child and parent relationship**
   
     **![image-20240101162121096](img/image-20240101162121096.png)**
   
     **==列出所有运行的进程！==信息包含：装载的DLL，进程属性，==进程父子关系==，Overall System information**
   
     ![image-20240101164800937](img/image-20240101164800937.png)
   
     服务：粉色。进程：蓝色（新进程：绿色）。终止：红色。
   
     具有**DLL模式和Handle模式**（Windows操作对象都有句柄）——每个进程打开的句柄和加载的 DLL。
   
     * **属性：DEP——数据执行保护，ASLR——地址空间布局随机化。**（某些Malware会强制打开这两者）
   
       **Verify——查看 the disk file's Windows signature（hash）。==不是内存映射，因此没法检测进程替换！！！==**
   
       It verifies files on disk rather than images in memory. 
       Process replacement: overwriting a normal process memory space with malicious codes
       **The image in memory is different from the image in disk.**
   
       ![image-20240101165618870](img/image-20240101165618870.png)
   
       *DEP是Windows操作系统中的数据执行保护（Data Execution Prevention）的缩写。它是一种安全机制，**旨在防止恶意软件利用内存漏洞来执行代码。**DEP通过将内存中的数据区域标记为不可执行，从而阻止恶意软件在这些区域中执行代码。这有助于保护系统免受缓冲区溢出和其他类型的攻击。用户可以在Windows系统中启用或禁用DEP功能。*
   
       *ASLR是地址空间布局随机化（Address Space Layout Randomization）的缩写，它是一种计算机安全技术，旨在增加操作系统和应用程序的安全性。ASLR通过在**系统和应用程序加载时随机化内存地址的分配**，使得攻击者更难以利用系统和应用程序中的漏洞进行攻击。*
   
       *在Windows操作系统中，ASLR可以随机化系统和应用程序的代码、数据和堆栈的位置，从而使攻击者难以预测要攻击的内存地址。这有助于防止针对系统和应用程序的缓冲区溢出等攻击。*
   
     * **Strings：能检测进程替换。**
   
       In basic static analysis, we only see strings in disk. Now, we can see stings in memory.
   
       ![image-20240101165711961](img/image-20240101165711961.png)
   
     * Process Explorer可以用来检测恶意文件
   
       ![image-20240101165934154](img/image-20240101165934154.png)
   
   * **注册表的动态监控：Regshot——Take ==registry snapshots==**
   
     ![image-20240101170904129](img/image-20240101170904129.png)
   
     ![image-20240101170952332](img/image-20240101170952332.png)
   
     ![image-20240101171011142](img/image-20240101171011142.png)
   
   * **==网络动态监控：==WireShark等**
   
     ![image-20240101171042788](img/image-20240101171042788.png)
   
     **==回答：隔离后可以伪造一个虚拟网络。==**We can create a fake network to **obtain network indicators** without actually connecting to the Internet. These indicators can include **DNS names, IP addresses, and packet signatures.**
     To fake a network successfully, you must prevent malware from realizing that it is executing in a VM. 
     There are some tools that we can select to setup a fake network to increase our chance of success.
     
     <img src="img/image-20240102114022096.png" alt="image-20240102114022096" style="zoom: 67%;" />
     
     * **ApateDNS：Using ApateDNS to Redirect DNS Resolutions。**
     
       It can capture all DNS requests（能够监听并拦截发往DNS服务器的请求） and spoof DNS responses to a user-specified IP address（**将DNS响应伪装成用户指定的IP地址**）。
     
       拦截了DNS请求之后，不是返回真实的域名对应IP地址，而是返回一个虚假的、由攻击者指定的IP地址。这个过程称为“DNS欺骗”（DNS Spoofing）。
     
     * **Monitoring with Ncat(included with Nmap)：the TCP/IP Swiss Army Knife.**
     
       After DNS redirection, **we need nc to listen on the malware http request. (nc -l -p 80)**
     
     * **WireShark：sniffer。**
     
       * captures packets
       * intercepts and logs network traffic
       * provide visualization
       * packet analysis
       * see a TCP session. right click a packet and select **Follow TCP Stream**
     
     * **inetsim：Linux-based** software suite for **simulating common Internet services**（HTTP, HTTPS, FTP, IRC, DNS, SMTP and others）.
     
       **欺骗浏览器。**The simulated server does not response 404 or other errors, **and its response, even if incorrect, can ==keep the malware running.==** 
     
       甚至可以欺骗Nmap
     
       **![image-20240102120145979](img/image-20240102120145979.png)** 
     
       ![image-20240102120346386](img/image-20240102120346386.png)
   
2. **沙箱**（自动生成分析报告）不考网上那些免费的

   Sandboxes: The Quick-and-Dirty Approach

   **All-in-one** software for basic dynamic analysis

   （all-in-one;一体化的， not only simulates system calls but also have to simulates network services.）

   Virtualized environment that **simulates network services。Malware误以为可以联网。**

   <img src="img/image-20240101160621754.png" alt="image-20240101160621754" style="zoom:67%;" />

   **==缺点：==**

   病毒潜伏；遇到静态扫描则触发反击

   <img src="img/image-20240101160658769.png" alt="image-20240101160658769" style="zoom: 80%;" />

   <img src="img/image-20240101160746627.png" alt="image-20240101160746627" style="zoom: 67%;" />

   <img src="img/image-20240101160806795.png" alt="image-20240101160806795" style="zoom:67%;" />

3. **DLL的动态分析【DLL无法双击运行】**（进程、注册表、网络等）

* 动态链接库程序的执行：**==rundll32.exe==** DLLname, Export arguments

  启动后真正运行的是进程中的线程。

  ![image-20240101160911954](img/image-20240101160911954.png)

  关于**exports即导出函数**：显式名字的；ordinal values序数值的(#5)。没有名字一定有序号。

  ![image-20240101161037179](img/image-20240101161037179.png)

* **服务：**

  * 载体有**DLL（大多数）**，EXE

  * Installed as a service：**安装服务（记录注册表）**。

  * **==启动服务：net start（见到病毒的strings，证明有服务启动） ServiceName==**

    <img src="img/image-20240101161241076.png" alt="image-20240101161241076" style="zoom:67%;" />

  * **服务与应用的区别**

    ![image-20240101161426795](img/image-20240101161426795.png)

    功能，用户交互，权限，生命周期，运行模式

    ![image-20240101161522228](img/image-20240101161522228.png)



<img src="img/image-20240102120506433.png" alt="image-20240102120506433" style="zoom: 50%;" />

![image-20240102120756401](img/image-20240102120756401.png)

<img src="img/image-20240102120705882.png" alt="image-20240102120705882" style="zoom:80%;" />

<img src="img/image-20240102120727036.png" alt="image-20240102120727036" style="zoom: 80%;" />

## 六. IDAPython

**==重点：手工病毒分析的自动化编程==**

函数，操作数，基本块，交叉引用，搜索

辅助病毒分析的工具。

基本块概念：代码序列个入口，只有最后一个语句一个出口，中间没有分支）

不用自动写IDAPython，病毒分析题手工分析即可

基本概念需要理解

函数会列在卷子上，匈牙利命名法/名字不用死记硬背。







1. **IDA：内存地址十六进制且没有0x前缀**

   <img src="img/image-20240102121015072.png" alt="image-20240102121015072" style="zoom: 67%;" />

   * **ea**表示内存地址，获得当前**光标所在位置**汇编语句的内存地址：idc.get_screen_ea()。here()

     %x——十六进制

     ![image-20240102121253096](img/image-20240102121253096.png)

   * 读取节信息：idc.get_segm_name(ea) 

   * 读取汇编语句：idc.generate_disasm_line(ea, 0)

   * 读取汇编指令（**助记符**）：idc.print_insn_mnem(ea) 

   * 读取第一个操作符：idc.print_operand(ea,0) 

   * 检测内存地址是否可以被访问：(idaapi./idc.)BADADDR 

   * 段信息：

     ![image-20240102121822745](img/image-20240102121822745.png)

     ![image-20240102121627088](img/image-20240102121627088.png)

2. **函数：**

   * idautils.Functions() 返回IDA识别出的**所有==函数入口点==列表**

   * idautils.Functions(start_addr, end_addr) ，可以指定显示某个范围的函数列表

   * idc.get_func_name(ea) 返回**函数名**，ea可以是函数内存范围内的任意一个地址

   * get_func(ea)：获取函数入口点，参数是ea地址

   * dir(func)函数属性

   * ea = idc.get_next_func(ea)：下一个地址

   * **next_head()** 函数——用于**遍历函数内部的汇编**指令

     <img src="img/image-20240102140312185.png" alt="image-20240102140312185" style="zoom: 67%;" />

   * **函数属性：9个。**

     * FUNC_NORET：不会返回retn的函数

     * FUNC_FAR和FUNC_USERFAR：函数的长调用，需要用到段寄存器。

     * FUNC_LIB：库函数，不对其进行逆向分析。

     * FUNC_STATIC：静态函数（**C/C++中，作用域仅在一个文件中**。不同的文件，可以定义相同名字的静态函数。）

     * **FUNC_FRAME：函数里面是否使用了帧指针（Frame Pointer）。EBP和BP。**

       **（栈指针是ESP和SP）**

     * **FUNC_BOTTOMBP：函数的帧指针（Frame Pointer）等于栈指针（Stack Pointer）**——frame pointer points to the bottom of the stack

     * FUNC_HIDDEN：隐藏函数——*If we were to go to an address of a function that is marked as hidden it would **automatically** be expanded.* 

     * **FUNC_THUNK：跳转到其它函数的函数**

       ```markdown
       栈指针（Stack Pointer）和帧指针（Frame Pointer）是在程序执行过程中用于管理函数调用和局部变量的两个重要的指针。它们在函数调用的上下文中有特定的用途和意义。
       
       ### 栈指针（Stack Pointer）
       
       栈指针是用于指向程序运行时栈的顶部的指针。在大多数现代架构中，栈是从高地址向低地址生长的，栈指针指向栈的最新（最高）位置。主要功能是：
       
       - 管理函数调用时参数的传递。
       - 控制局部变量的分配和回收。
       
       在x86架构中，栈指针通常由寄存器 `ESP`（扩展堆栈指针，Extended Stack Pointer）在32位模式下表示，或 `SP`（堆栈指针，Stack Pointer）在16位模式下表示。
       
       ### 帧指针（Frame Pointer）
       
       帧指针用于指向函数栈帧的基址。栈帧是函数调用时在栈上分配的内存区域，用于存储函数的局部变量、参数、返回地址等信息。主要功能是：
       
       - 提供一个固定的参考点，用于访问函数的参数和局部变量。
       - 在调试和异常处理中提供一个清晰的函数调用链。
       
       在x86架构中，帧指针通常由寄存器 `EBP`（扩展基指针，Extended Base Pointer）在32位模式下表示，或 `BP`（基指针，Base Pointer）在16位模式下表示。
       
       ### 二者关系
       
       - 在函数调用的开始阶段，`EBP`/`BP`通常被设置为当前的`ESP`/`SP`值，这样它们就指向同一个地址，即当前的栈帧基址。
       - 随着函数执行，`ESP`/`SP`会移动以分配局部变量或响应函数内的其他栈操作，而`EBP`/`BP`保持不变，指向固定的栈帧基址。
       - 在函数返回之前，`ESP`/`SP`通常被重置回`EBP`/`BP`的值，以丢弃局部变量，然后根据保存在栈上的返回地址跳回到调用函数。
       
       因此，`ESP`/`SP`是动态变化的，随着函数执行和栈操作而上下移动，而`EBP`/`BP`则是静态的，在整个函数执行期间都指向同一个地址。这种分离使得即使在复杂的栈操作中，也能稳定地访问函数的参数和局部变量。
       ```

   * idautils.**FuncItems(ea) ==返回函数中汇编指令的地址==**

     ![image-20240102142147879](img/image-20240102142147879.png)

     ![image-20240102142445634](img/image-20240102142445634.png)

     找到所有非库函数和直接跳转函数里面call和jmp指令的目的寄存器地址

3. **操作数：**

   * **操作数的类型：idc.get_operand_type(ea,n)** 
     ea是指令地址
     n是操作数的索引

     **（以下为函数返回值1-6）**

   * o_void：指令没有操作数。return。
   * o_reg：操作数是寄存器。pop edi
   * o_mem：操作数是内存地址。ds:dword_A152B8
   * o_phrase：操作数是寄存器的表达式。[edi+ecx]
   * o_displ：操作数是寄存器加位移数值（displacement value）。[edi+18h]
   * o_imm：操作数是立即数。0Ch

   **==op_plain_offset将操作数改成offset。==**用于将某个指令的操作数修改为偏移量（offset）形式。从它的原始形式（可能是一个直接的数值或地址）转换为一个相对于某个基地址的偏移量。

   <img src="img/image-20240102143249056.png" alt="image-20240102143249056" style="zoom:67%;" />

4. **基本块：**

   **基本块是一段==代码序列==，该代码序列==没有分支==，也就是只有一个入口点和一个出口点**

   IDA的图形模式

   控制流混淆中xor cl, ds:b_key可能就是在XOR加密

   ![image-20240102143528936](img/image-20240102143528936.png)

   <img src="img/image-20240102143447367.png" alt="image-20240102143447367" style="zoom:67%;" />

5. **交叉引用：**

   用于分析**数据或代码**被引用的信息

   * 代码/数据交叉引用：
     * 先idc**.get_name_ea_simple(str) 返回API函数的地址。**
     * 后idautils.Code/DataRefsTo(ea, flow).返回代码交叉引用的地址
       CodeRefs**==To返回调用该函数==**的地址
       CodeRefs**==From返回该函数调用的函数==**地址
   * idautils.XrefsFrom(ea, flags=0) 

6. **搜索——代码、文本、立即数：ida_search.find_binary**

   ![image-20240102145618561](img/image-20240102145618561.png)

   **==sflag是搜索的方向或者条件。==**

   默认同时搜索Unicode和ASCII。

   

   <img src="img/image-20240102145719010.png" alt="image-20240102145719010" style="zoom:67%;" />

   只使用一个DOWN会重复出现，加一个NEXT

   <img src="img/image-20240102150020070.png" alt="image-20240102150020070" style="zoom: 50%;" />

   搜索文本

   ![image-20240102150302723](img/image-20240102150302723.png)

   搜索立即数

   ![image-20240102150323831](img/image-20240102150323831.png)



重点：什么是基本块。

## 七.恶意代码分析

![image-20231225081916096](C:\Users\zyc13\AppData\Roaming\Typora\typora-user-images\image-20231225081916096.png)

**重点**

什么是API(名字+匈牙利)【最常见的打开文件可能要记，不常用的会说出什么作用，有标记】

**APC Detours DLL Injection的API不再提示！需要背**



Windows API和注册表

网络注册表（send，等计网东西）

内核用户模式的概念，

![image-20240107191325682](img/image-20240107191325682.png)



原生API（和Windows API的区别）

![image-20240107191432512](img/image-20240107191432512.png)







![image-20240105150230091](img/image-20240105150230091.png)

![image-20240105150246075](img/image-20240105150246075.png)

![image-20240105150311796](img/image-20240105150311796.png)

![image-20240105150348999](img/image-20240105150348999.png)

![image-20240105150437607](img/image-20240105150437607.png)

ADS能躲避静态扫描和杀毒软件

### 注册表

<img src="img/image-20240105151236000.png" alt="image-20240105151236000" style="zoom: 67%;" />

<img src="img/image-20240105151712289.png" alt="image-20240105151712289" style="zoom:67%;" />

<img src="img/image-20240105151846464.png" alt="image-20240105151846464" style="zoom:67%;" />

<img src="img/image-20240105152630586.png" alt="image-20240105152630586" style="zoom:67%;" />



### 跟踪恶意代码运行

不是重点

![image-20240105154246140](img/image-20240105154246140.png)

![image-20240105155147247](img/image-20240105155147247.png)

### 互斥量

 <img src="img/image-20240105161623690.png" alt="image-20240105161623690" style="zoom:67%;" />

### 服务

![image-20240105162558698](img/image-20240105162558698.png)

<img src="img/image-20240105162730518.png" alt="image-20240105162730518" style="zoom:67%;" />

### COM

![image-20240105163913646](img/image-20240105163913646.png)

第三方比如浏览器

![image-20240105164849198](img/image-20240105164849198.png)

<img src="img/image-20240105165206105.png" alt="image-20240105165206105" style="zoom:67%;" />

 内核模式与用户模式

**0——内核，3——用户**

![image-20240105170134629](img/image-20240105170134629.png)

![image-20240105170400591](img/image-20240105170400591.png)   

![image-20240105170519469](img/image-20240105170519469.png)  

![image-20240105170621079](img/image-20240105170621079.png)

### 原生API

![image-20240105171300333](img/image-20240105171300333.png)

![image-20240105171458670](img/image-20240105171458670.png)

**==Ntdll.dll==**

![image-20240105171643094](img/image-20240105171643094.png)



## 八.动态调试

录音：17：42秒

![image-20231225081959924](C:\Users\zyc13\AppData\Roaming\Typora\typora-user-images\image-20231225081959924.png)

异常不考！！！！



内核（WinDBG）和用户模式（OllyDBG）

WinDBG内核和用户都可以做

**==内核和用户的区别==**（权限，内核模式单任务等等）

理解知识点，没讲

<img src="img/image-20240105173421901.png" alt="image-20240105173421901" style="zoom:67%;" />

![image-20240105173751490](img/image-20240105173751490.png)

![image-20240105174101232](img/image-20240105174101232.png)

**==重点==**

 ![image-20240105174148129](img/image-20240105174148129.png)

![image-20240105174248305](img/image-20240105174248305.png)

**也包括我们的内核调试程序。不能在同一个内核中既运行我们要调试的程序，又运行我们的内核调试器。**

![image-20240105174354640](img/image-20240105174354640.png)

被调试的代码（内核上的计算机代码）配置OS（选择Debugging Mode），通过串口来通信。

![image-20240105174543263](img/image-20240105174543263.png)





使用调试器

**在其入口点运行之前就停下了**

![image-20240105183822394](img/image-20240105183822394.png)

附加调试器方法——针对已经运行起来的程序

![image-20240105184008071](img/image-20240105184008071.png)

**单步调试，单步跳过，单步跳入，单步跳出**

![image-20240105184113681](img/image-20240105184113681.png)

![image-20240105184316793](img/image-20240105184316793.png)

![image-20240105184859965](img/image-20240105184859965.png)



断点类型——软件、硬件、条件 

<img src="img/image-20240105185750873.png" alt="image-20240105185750873" style="zoom: 67%;" />

![image-20240105190117927](img/image-20240105190117927.png)

![image-20240105190238878](img/image-20240105190238878.png)

<img src="img/image-20240105190352481.png" alt="image-20240105190352481" style="zoom:67%;" />

![image-20240105190619363](img/image-20240105190619363.png)

![image-20240105190626729](img/image-20240105190626729.png)

![image-20240105190744382](img/image-20240105190744382.png)

## 九.==WinDBG==

![image-20231225082400992](C:\Users\zyc13\AppData\Roaming\Typora\typora-user-images\image-20231225082400992.png)

### 重点章节以及知识点（PPT+教材）

什么是设备，驱动以及物理设备

答：

#### 基本概念一

**device和physical device的区别：硬件设备的软件表示**

**驱动是什么**

**app是不是可以直接访问以上三者**

#### WinDBG的基本操作

lm命令

读内存d开头

写内存edit

ascii开头a，unicode开头u

背的时候理解动词和名词，动词+名词

PPT上的操作要能够理解

#### 内核调试实战（看课本！！）

#### Rootkit

实战之后的例子，如何分析一个这玩意

**ssdt和idt的概念**

**Rootkit只将了一种：Hook和SSDT，就考这个**



### WinDBG

<img src="img/image-20240105193055063.png" alt="image-20240105193055063" style="zoom:67%;" />

**驱动程序**

<img src="img/image-20240105193654320.png" alt="image-20240105193654320" style="zoom:50%;" />

需要通过设备对象——计算机物理设备在用户空间的软件表示（设备对象的管理是由驱动程序负责的）

![image-20240105193802874](img/image-20240105193802874.png)

APP通过将访问请求发给设备对象，然后访问请求被转发给驱动程序，驱动程序访问。

![image-20240105194001307](img/image-20240105194001307.png)

驱动执行的第一个函数——DriverEntry

![image-20240105194127395](img/image-20240105194127395.png)

第三条。**DriverEntry函数会修改设备对象中的call back函数，使得设备对象能够通过callback函数来响应其他应用程序的设备请求。**

![image-20240105194701936](img/image-20240105194701936.png)



![image-20240105195017353](img/image-20240105195017353.png)

![image-20240105195148127](img/image-20240105195148127.png)

![image-20240105195853466](img/image-20240105195853466.png)



![image-20240105202541307](img/image-20240105202541307.png)

串口一端虚拟机，另一端是虚拟机调试设备WINDBG

![image-20240105203007190](img/image-20240105203007190.png)

![image-20240105203321071](img/image-20240105203321071.png)

<img src="img/image-20240105203332376.png" alt="image-20240105203332376" style="zoom:67%;" />

![image-20240105203708727](img/image-20240105203708727.png)

![image-20240105203808639](img/image-20240105203808639.png)

![image-20240105203848056](img/image-20240105203848056.png)

然后可以定位哪些模块是Malware调用的模块/

![image-20240105203929316](img/image-20240105203929316.png)



#### Windows符号表

**调试符号。**==对内存地址的符号化表示==

![image-20240105210339632](img/image-20240105210339632.png)



<img src="img/image-20240105210451570.png" alt="image-20240105210451570" style="zoom:67%;" />

![image-20240105211009795](img/image-20240105211009795.png)

![image-20240105211245496](img/image-20240105211245496.png)

![image-20240105211342241](img/image-20240105211342241.png)

![image-20240105211510646](img/image-20240105211510646.png)



![image-20240105212054456](img/image-20240105212054456.png)

![image-20240105212508461](img/image-20240105212508461.png)









![image-20240105212704575](img/image-20240105212704575.png)

![image-20240105212954428](img/image-20240105212954428.png)

![image-20240105213041245](img/image-20240105213041245.png)







**==记住内核驱动是不会经常装载与卸载。==**

**==这里很明显说明动态装载内核行为的可疑！！==**

除了Kmixer.sys

![image-20240105213420048](img/image-20240105213420048.png)







**==RootKit==**

![image-20240105214820266](img/image-20240105214820266.png)

**==SSDT——系统服务描述符表。存的是ntoskrnel.exe中的函数。==**

![image-20240105214911997](img/image-20240105214911997.png)

![image-20240105214931858](img/image-20240105214931858.png)

**遍历SSDT中是否都是这个范围内的**

![image-20240105215515231](img/image-20240105215515231.png)

**==lm m nt！！！==**

<img src="img/image-20240105215619264.png" alt="image-20240105215619264" style="zoom:150%;" />











**恶意代码还可以对中断进行截获**

![image-20240105220235081](img/image-20240105220235081.png)

![image-20240105220252305](img/image-20240105220252305.png)

**==IDT——中断描述符表==**

![image-20240105220540401](img/image-20240105220540401.png)



![image-20240105220827662](img/image-20240105220827662.png)

## 十一.恶意行为

![image-20231225082643978](C:\Users\zyc13\AppData\Roaming\Typora\typora-user-images\image-20231225082643978.png)

**==后门：shellrevershell的概念，什么是revershell==**

**![image-20240106192212586](img/image-20240106192212586.png)**

![image-20240106192307984](img/image-20240106192307984.png)

本质上是一个后门

![image-20240106192459692](img/image-20240106192459692.png)

![image-20240106192935931](img/image-20240106192935931.png)



![image-20240106193104165](img/image-20240106193104165.png)

![image-20240106193240769](img/image-20240106193240769.png)

**==rat，botnets，区别和相似性==**

![image-20240106193321580](img/image-20240106193321580.png)

<img src="img/image-20240106193432954.png" alt="image-20240106193432954" style="zoom:50%;" />

![image-20240106193514147](img/image-20240106193514147.png)

使这个节点被瘫痪

**区别！！！！**

![image-20240106193616969](img/image-20240106193616969.png)







**==凭证窃取——什么是gina，LSASS？看看实验报告等等==！**

![image-20240106193848745](img/image-20240106193848745.png)

![image-20240106194040280](img/image-20240106194040280.png)

![image-20240106194102314](img/image-20240106194102314.png)

<img src="img/image-20240106194214334.png" alt="image-20240106194214334" style="zoom:50%;" />

MITMAttack（王志没提）

![image-20240106194321218](img/image-20240106194321218.png)

![image-20240106194538080](img/image-20240106194538080.png)





![image-20240106194949139](img/image-20240106194949139.png)

![image-20240106195040920](img/image-20240106195040920.png)

**==LSASS==**

**有很高的权限，可以访问本地用户的LM和NTLM的口令哈希值。**

![image-20240106195212689](img/image-20240106195212689.png)

多次调用GetProcAddress（王没

![image-20240106200009839](img/image-20240106200009839.png)

这部分王志没提（击键记录器

<img src="img/image-20240106200328322.png" alt="image-20240106200328322" style="zoom:50%;" />

常用的是Hooking和pooling（王没

![image-20240106200539987](img/image-20240106200539987.png)







**持久性机制（存活机制），除了。AppInit（跟着什么？什么时候自启动?是不是User32启动）**



![image-20240106200920827](img/image-20240106200920827.png)

![image-20240106201422371](img/image-20240106201422371.png)

![image-20240106201025558](img/image-20240106201025558.png)

**===AppInit_DLL===**

会加载到多个进程中（所有使用User32的进程中）。因此检查自己在哪个进程中。

<img src="img/image-20240106201113784.png" alt="image-20240106201113784" style="zoom: 67%;" />

**Winlogon（登陆时候自启动）**

注意安全模式

![image-20240106202106304](img/image-20240106202106304.png)

**SVChost究竟是什么，存了什么（以动态链接库的形式运行在svchost.exe的进程空间中，共享方式运行的服务）**

![image-20240106202304172](img/image-20240106202304172.png) 

![image-20240106202439127](img/image-20240106202439127.png)
需要在以下两个位置都要注册

![image-20240106202541776](img/image-20240106202541776.png)

CreateService

![image-20240106202836897](img/image-20240106202836897.png)





王志没提，可能不是重点。。。

<img src="img/image-20240106203408743.png" alt="image-20240106203408743" style="zoom:50%;" />

<img src="img/image-20240106203449233.png" alt="image-20240106203449233" style="zoom:67%;" />

![image-20240106203829202](img/image-20240106203829202.png)

<img src="img/image-20240106204138475.png" alt="image-20240106204138475" style="zoom:50%;" />

![image-20240106204821619](img/image-20240106204821619.png)

![image-20240106204815052](img/image-20240106204815052.png)

**权限提升（病毒可能提升到system系统权限或者core态）**



**如何提升权限**

其中最后一种是将DLL加载到更高权限的进程中

![image-20240106205025054](img/image-20240106205025054.png)

SeDebugPrivilege——system系统权限

具体是通过AdjustTokenPrivileges（看PPT）

![image-20240106205153572](img/image-20240106205153572.png)

**用户模式的Rootkit，之前需要记用户模式的Rootkit（R77）。R77实验，进程文件网络通信隐藏等。**

在用户空间中实现Rootkit功能

几种方法

IAT——大量函数入口地址（比如调用一个系统函数

修改地址表（正常函数入口位置——恶意代码函数）最后到正常程序，避免被发现（增强隐蔽性）或者crash掉她自己也没了（程序正常运行）。

<img src="img/image-20240106205555712.png" alt="image-20240106205555712" style="zoom:50%;" />

实际去改变函数段代码，而不是指针

![image-20240106205830378](img/image-20240106205830378.png)

也得交回给正常程序

![image-20240106210028723](img/image-20240106210028723.png)





![image-20240106210236617](img/image-20240106210236617.png)

## 十二.隐蔽执行技术

![image-20231225082924590](C:\Users\zyc13\AppData\Roaming\Typora\typora-user-images\image-20231225082924590.png)

隐蔽的启动

**下载器和启动器的区别。**



**==重点一==**

![image-20240106192009365](img/image-20240106192009365.png)



![image-20240106192112000](img/image-20240106192112000.png)

更详细的：



![image-20240106210431532](img/image-20240106210431532.png)

定位启动器的函数（王没

![image-20240106210447521](img/image-20240106210447521.png)

**进程注入（DLL注入和直接注入等）**

传统的防火墙是以进程为检测对象，进程注入可以隐藏在正常进程中

![image-20240106210600993](img/image-20240106210600993.png)

![image-20240106210849642](img/image-20240106210849642.png)

DLL注入是一种形式。隐藏在DLLMain中

![image-20240106210917064](img/image-20240106210917064.png)

同样的权限

![image-20240106211030183](img/image-20240106211030183.png)

区别：不是单独编写DLL，而是直接将Malware注入到远程进程中。

![image-20240106212023178](img/image-20240106212023178.png)

注入ShellCode。要求编写难度更大，Crash后会被发现。

![image-20240106212105815](img/image-20240106212105815.png)

第一次写入数据，第二次写入代码

编译代码——LoL，GPA

![image-20240106212225890](img/image-20240106212225890.png)



**独立进程（风险大）执行恶意代码数量少，DLL执行的病毒更为常见（风险小，并且需要注入LLASS，可以进行权限提升访问密码）**

**注册到浏览器，可以通过防火墙（一般通过不了）**



**如何替换进程（难点：==Suspended State：什么是？为什么需要==）**

![image-20240106212337871](img/image-20240106212337871.png)

![image-20240106212607124](img/image-20240106212607124.png)



![image-20240106213216187](img/image-20240106213216187.png)

通过防火墙，IPS等

![image-20240106213948958](img/image-20240106213948958.png)

使用原始的二进制路径。

使用进程替换器只能看到最开始被加载时候干净文件的信息

![image-20240106214053312](img/image-20240106214053312.png)



**HOOK Injection（本地与远程HOOK，远程的优点和问题）**

Malware挂钩的目的是执行进程

![image-20240106214821487](img/image-20240106214821487.png)

![image-20240106214849044](img/image-20240106214849044.png)

**所有进程都会被hook，并且效率下降很明显【看PPT！！！】**

上面的是被保存在系统中所有线程的空间。

利用Windows钩子机制实现代码的自动触发

![image-20240106214439976](img/image-20240106214439976.png)

![image-20240106214547457](img/image-20240106214547457.png)



SetWindowsHookEx——lpfn

![image-20240106215114092](img/image-20240106215114092.png)

![image-20240106220617487](img/image-20240106220617487.png)

![image-20240106220715133](img/image-20240106220715133.png)

**可能说的是这里！！！！背一下。**

![image-20240106220918841](img/image-20240106220918841.png)



挂钩一些不经常使用的——WH_CBT

![image-20240106221248502](img/image-20240106221248502.png)

在DLLMAIN中立马UnHook保证不被干扰

![image-20240106221807419](img/image-20240106221807419.png)

R77可以看看实验报告



**==Detours技术对文件进行修改（也可以达到自启动），其他技术都是修改正在进行的进程（内存。Hook和Injection）==**

Rootkit用

它是一个库，**修改的是二进制文件**（看英文PPT这里）

![image-20240106222125888](img/image-20240106222125888.png)

**APC注入（什么是APC？）APC怎么去做HOOK(其他技术都是对用户空间做了一些隐蔽启动，APC可以对内核空间做隐蔽启动。)**

当一个程序处于等待状态等，CPU控制权就会转移到这些APC队列的函数中

![image-20240106222703304](img/image-20240106222703304.png)

使用现有的线程实现注入功能

![image-20240106222501514](img/image-20240106222501514.png)

**==（APC注入引来的概念）Alertable State：是否会被触发？？==**

![image-20240106223043866](img/image-20240106223043866.png)

![image-20240106223157769](img/image-20240106223157769.png)

![image-20240106223430493](img/image-20240106223430493.png)



![image-20240106223801561](img/image-20240106223801561.png)

![image-20240106223952842](img/image-20240106223952842.png)



![image-20240106224512977](img/image-20240106224512977.png)

## 十三：数据加密

**==为什么病毒要使用加密？对病毒的好处==**

第一点使逆向分析更加困难

第二点也是增加难度 

第三点就是对抗计算机病毒分析，将其隐藏

最后一个

![image-20240107133035296](img/image-20240107133035296.png)

**![image-20240107122945399](img/image-20240107122945399.png)**

**加密（Simple）：有哪些最简单（是否可以直接用加法加密，减法解密？）凯撒！**

**XOR异或（只需要一个CPU指令，加解密都是异或，比凯撒还要简单）有很多的0，只要对0异或就可以暴露密钥。==这时候如何增强XOR的隐蔽性？==**![image-20240107124332901](img/image-20240107124332901.png)

![image-20240107124431551](img/image-20240107124431551.png)

![image-20240107124546719](img/image-20240107124546719.png)





其它

![image-20240107124025186](img/image-20240107124025186.png)

暴力破解找MZ头

![image-20240107124108516](img/image-20240107124108516.png)

![image-20240107124233479](img/image-20240107124233479.png)

![image-20240107123634336](img/image-20240107123634336.png)

**Base64网络通信上使用（Cookie，URL，UserAgent）有哪些升级的方法？最明显的特征（64个字符的字符串，依靠其进行加密和解密。字符串也可以变得更高混淆一些）**

Base加解密后一定是可打印的

![image-20240107125425869](img/image-20240107125425869.png)

![image-20240107130032971](img/image-20240107130032971.png)

![image-20240107130127966](img/image-20240107130127966.png)

![image-20240107130137489](img/image-20240107130137489.png)

![image-20240107130210966](img/image-20240107130210966.png)

**更加安全的密码（数学证明过的。优点就是保护强度非常大）勒索病毒使用的Common Cryptography**

<img src="img/image-20240107130525411.png" alt="image-20240107130525411" style="zoom:67%;" />

![image-20240107130627346](img/image-20240107130627346.png)

3. Crypt，CP或者Cert

4. FindCrypt2（可以用RC4抵抗）后者是PEiD的插件（更多的false positives）也有Base64 Tables

![image-20240107130737512](img/image-20240107130737512.png)

**信息熵（什么是？能给我们哪些帮助）**衡量信息量

5. 高熵值内容——最大熵定理：等概率场的平均不确定性最大。0-255的Byte，平均分布最大熵就是8，都一样就是0

   代码区域峰值不会很高，但是平均高

   ![image-20240107131233460](img/image-20240107131233460.png)

**Custom Encoding（对SImple改造，两次Simple Cipher：XOR+凯撒，XOR+Base64等）**

![image-20240107131605999](img/image-20240107131605999.png)

![image-20240107131906376](img/image-20240107131906376.png)

加密和输入一般不会太远

![image-20240107131949749](img/image-20240107131949749.png)

小并且nonobvious

![image-20240107132221113](img/image-20240107132221113.png)



**Decoding对于加密我们应该怎么分析（被加密的数据或者代码进行还原）简单的加密算法可以调用标准的解密函数或者IDA Python**

**嵌套了好几层的加密或非标准（IDA Python不太行。）此时应该怎么做？==自解密！==**

**病毒一定会解密出来才能执行。设置断点让解密后程序中断。或者解密的代码直接拿出来分析。利用它们自己的解密）**

**劫持僵尸网络（？**

<img src="img/image-20240107132751034.png" alt="image-20240107132751034" style="zoom: 67%;" />

**![image-20240107132416360](img/image-20240107132416360.png)**





## 十四：网络1行为

需要理解网络上面的工具

WireShark，防火墙以外的其它方法的原理实现了恶意代码的阻断需要有理解，

![image-20240107134530861](img/image-20240107134530861.png)

**基于内容的应对措施——深度数据包检测**

**病毒防治的工具：IDS,IPS？（概念，以及区别和联系）****什么是DPI（基于内容）**

![image-20240107134814940](img/image-20240107134814940.png)

![image-20240107134857268](img/image-20240107134857268.png)

**数据包（需要解开数据包）。之后能做的IDS,IPS。解开Email数据包-Email代理。**

**Email 和 Web代理（对于网络防御能起到作用是？）**

![image-20240107134753660](img/image-20240107134753660.png)

![image-20240107135137864](img/image-20240107135137864.png)

**==DNS 沉洞？能做什么==**

![image-20240107134639083](img/image-20240107134639083.png)

其他方法基于什么理论和原理实现的恶意行为阻断



## 实验Labs：



## 考试

实验报告+**PPT知识点（主要）**

**大题可能涉及到实验报告。WinDBG的**

不要死记硬背，经常用到的API！！！

一些IDA命令和WinDBG的命令应该都会有提示。

